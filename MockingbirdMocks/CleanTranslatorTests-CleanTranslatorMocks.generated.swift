//
//  CleanTranslatorTests-CleanTranslatorMocks.generated.swift
//  CleanTranslator
//
//  Generated by Mockingbird v0.20.0.
//  DO NOT EDIT
//

// swiftlint:disable all

@testable import CleanTranslator
@testable import Mockingbird
import Alamofire
import Apexy
import Foundation
import SnapKit
import Swift
import UIKit

private let mkbGenericStaticMockContext = Mockingbird.GenericStaticMockContext()

// MARK: - Mocked AlertFactory
public final class AlertFactoryMock: CleanTranslator.AlertFactory, Mockingbird.Mock {
  typealias MockingbirdSupertype = CleanTranslator.AlertFactory
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "CleanTranslator"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    AlertFactoryMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `createErrorAlert`(`message`: String?)
  public func `createErrorAlert`(`message`: String?) -> UIKit.UIViewController {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`createErrorAlert`(`message`: String?) -> UIKit.UIViewController", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`message`)], returnType: Swift.ObjectIdentifier((UIKit.UIViewController).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (String?) -> UIKit.UIViewController { return mkbImpl(`message`) }
      if let mkbImpl = mkbImpl as? () -> UIKit.UIViewController { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: UIKit.UIViewController = mkbObject.`createErrorAlert`(message: `message`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (UIKit.UIViewController).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `createErrorAlert`(`message`: @autoclosure () -> String?) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String?) -> UIKit.UIViewController, UIKit.UIViewController> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String?) -> UIKit.UIViewController, UIKit.UIViewController>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`createErrorAlert`(`message`: String?) -> UIKit.UIViewController", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`message`)], returnType: Swift.ObjectIdentifier((UIKit.UIViewController).self)))
  }
}

/// Returns a concrete mock of `AlertFactory`.
public func mock(_ type: CleanTranslator.AlertFactory.Protocol, file: StaticString = #file, line: UInt = #line) -> AlertFactoryMock {
  return AlertFactoryMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked ProtocolWithGeneric
public final class ProtocolWithGenericMock: CleanTranslator.ProtocolWithGeneric, Mockingbird.Mock {
  typealias MockingbirdSupertype = CleanTranslator.ProtocolWithGeneric
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "CleanTranslator"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    ProtocolWithGenericMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `methodWithGeneric`<T>(`lhs`: T, `rhs`: T)
  public func `methodWithGeneric`<T>(`lhs`: T, `rhs`: T) -> Bool {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`methodWithGeneric`<T>(`lhs`: T, `rhs`: T) -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`lhs`), Mockingbird.ArgumentMatcher(`rhs`)], returnType: Swift.ObjectIdentifier((Bool).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (T, T) -> Bool { return mkbImpl(`lhs`, `rhs`) }
      if let mkbImpl = mkbImpl as? () -> Bool { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Bool = mkbObject.`methodWithGeneric`(lhs: `lhs`, rhs: `rhs`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Bool).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `methodWithGeneric`<T>(`lhs`: @autoclosure () -> T, `rhs`: @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (T, T) -> Bool, Bool> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (T, T) -> Bool, Bool>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`methodWithGeneric`<T>(`lhs`: T, `rhs`: T) -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`lhs`), Mockingbird.resolve(`rhs`)], returnType: Swift.ObjectIdentifier((Bool).self)))
  }

  // MARK: Mocked `methodWithGenericConstraint`<U>(`param`: [U])
  public func `methodWithGenericConstraint`<U>(`param`: [U]) -> U where U: Swift.Equatable {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`methodWithGenericConstraint`<U>(`param`: [U]) -> U where U: Swift.Equatable", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`param`)], returnType: Swift.ObjectIdentifier((U).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? ([U]) -> U { return mkbImpl(`param`) }
      if let mkbImpl = mkbImpl as? () -> U { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: U = mkbObject.`methodWithGenericConstraint`(param: `param`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (U).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `methodWithGenericConstraint`<U>(`param`: @autoclosure () -> [U]) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([U]) -> U, U> where U: Swift.Equatable {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([U]) -> U, U>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`methodWithGenericConstraint`<U>(`param`: [U]) -> U where U: Swift.Equatable", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`param`)], returnType: Swift.ObjectIdentifier((U).self)))
  }
}

/// Returns a concrete mock of `ProtocolWithGeneric`.
public func mock(_ type: CleanTranslator.ProtocolWithGeneric.Protocol, file: StaticString = #file, line: UInt = #line) -> ProtocolWithGenericMock {
  return ProtocolWithGenericMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked ProtocolWithMethodThatThrows
public final class ProtocolWithMethodThatThrowsMock: CleanTranslator.ProtocolWithMethodThatThrows, Mockingbird.Mock {
  typealias MockingbirdSupertype = CleanTranslator.ProtocolWithMethodThatThrows
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "CleanTranslator"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    ProtocolWithMethodThatThrowsMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `methodThatReturnsAndThrows`(`param`: Int)
  public func `methodThatReturnsAndThrows`(`param`: Int) throws -> Bool {
    return try self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`methodThatReturnsAndThrows`(`param`: Int) throws -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`param`)], returnType: Swift.ObjectIdentifier((Bool).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (Int) throws -> Bool { return try mkbImpl(`param`) }
      if let mkbImpl = mkbImpl as? () throws -> Bool { return try mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Bool = try mkbObject.`methodThatReturnsAndThrows`(param: `param`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Bool).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `methodThatReturnsAndThrows`(`param`: @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, (Int) throws -> Bool, Bool> {
    return Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, (Int) throws -> Bool, Bool>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`methodThatReturnsAndThrows`(`param`: Int) throws -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`param`)], returnType: Swift.ObjectIdentifier((Bool).self)))
  }

  // MARK: Mocked `methodThatThrows`()
  public func `methodThatThrows`() throws -> Void {
    return try self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`methodThatThrows`() throws -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () throws -> Void { return try mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = try mkbObject.`methodThatThrows`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `methodThatThrows`() -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, () throws -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, () throws -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`methodThatThrows`() throws -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns a concrete mock of `ProtocolWithMethodThatThrows`.
public func mock(_ type: CleanTranslator.ProtocolWithMethodThatThrows.Protocol, file: StaticString = #file, line: UInt = #line) -> ProtocolWithMethodThatThrowsMock {
  return ProtocolWithMethodThatThrowsMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked ProtocolWithProperties
public final class ProtocolWithPropertiesMock: CleanTranslator.ProtocolWithProperties, Mockingbird.Mock {
  typealias MockingbirdSupertype = CleanTranslator.ProtocolWithProperties
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "CleanTranslator"])

  // MARK: Mocked someGetProperty
  public var `someGetProperty`: String {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "someGetProperty.getter", setterSelectorName: "someGetProperty.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((String).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> String { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as String }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            break
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: String = mkbObject.`someGetProperty`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (String).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getSomeGetProperty() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String, String> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String, String>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "someGetProperty.getter", setterSelectorName: "someGetProperty.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((String).self)))
  }

  // MARK: Mocked someGetSetProperty
  public var `someGetSetProperty`: Int {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "someGetSetProperty.getter", setterSelectorName: "someGetSetProperty.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((Int).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> Int { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Int }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            break
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Int = mkbObject.`someGetSetProperty`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Int).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
    set {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "someGetSetProperty.setter", setterSelectorName: "someGetSetProperty.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? (Int) -> Void { return mkbImpl(newValue) }
        if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
        if let mkbImpl = mkbImpl as? (Any?) -> Any { return Mockingbird.dynamicCast(mkbImpl(newValue as Any?)) as Void }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Void }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            break
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Void = mkbObject.`someGetSetProperty` = newValue
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getSomeGetSetProperty() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> Int, Int> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> Int, Int>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "someGetSetProperty.getter", setterSelectorName: "someGetSetProperty.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((Int).self)))
  }

  public func setSomeGetSetProperty(_ newValue: @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (Int) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (Int) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "someGetSetProperty.setter", setterSelectorName: "someGetSetProperty.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.resolve(newValue)], returnType: Swift.ObjectIdentifier(Void.self)))
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    ProtocolWithPropertiesMock.mockingbirdContext.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `ProtocolWithProperties`.
public func mock(_ type: CleanTranslator.ProtocolWithProperties.Protocol, file: StaticString = #file, line: UInt = #line) -> ProtocolWithPropertiesMock {
  return ProtocolWithPropertiesMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked ProtocolWithStatic
public final class ProtocolWithStaticMock: CleanTranslator.ProtocolWithStatic, Mockingbird.Mock {
  typealias MockingbirdSupertype = CleanTranslator.ProtocolWithStatic
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "CleanTranslator"])

  // MARK: Mocked staticProperty
  public class var `staticProperty`: String {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "staticProperty.getter", setterSelectorName: "staticProperty.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((String).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> String { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as String }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            break
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype.Type else { break }
            let mkbValue: String = mkbObject.`staticProperty`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (String).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public class func getStaticProperty() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String, String> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String, String>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "staticProperty.getter", setterSelectorName: "staticProperty.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((String).self)))
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    ProtocolWithStaticMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `staticMethod`(`param`: Int)
  public static func `staticMethod`(`param`: Int) throws -> Int {
    return try self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`staticMethod`(`param`: Int) throws -> Int", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`param`)], returnType: Swift.ObjectIdentifier((Int).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (Int) throws -> Int { return try mkbImpl(`param`) }
      if let mkbImpl = mkbImpl as? () throws -> Int { return try mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype.Type else { break }
          let mkbValue: Int = try mkbObject.`staticMethod`(param: `param`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Int).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public static func `staticMethod`(`param`: @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, (Int) throws -> Int, Int> {
    return Mockingbird.Mockable<Mockingbird.ThrowingFunctionDeclaration, (Int) throws -> Int, Int>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`staticMethod`(`param`: Int) throws -> Int", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`param`)], returnType: Swift.ObjectIdentifier((Int).self)))
  }
}

/// Returns a concrete mock of `ProtocolWithStatic`.
public func mock(_ type: CleanTranslator.ProtocolWithStatic.Protocol, file: StaticString = #file, line: UInt = #line) -> ProtocolWithStaticMock {
  return ProtocolWithStaticMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked ProtocolsWithSimpleMethods
public final class ProtocolsWithSimpleMethodsMock: CleanTranslator.ProtocolsWithSimpleMethods, Mockingbird.Mock {
  typealias MockingbirdSupertype = CleanTranslator.ProtocolsWithSimpleMethods
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "CleanTranslator"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    ProtocolsWithSimpleMethodsMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `simpleMethodThatReturns`()
  public func `simpleMethodThatReturns`() -> Int {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`simpleMethodThatReturns`() -> Int", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Int).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> Int { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Int = mkbObject.`simpleMethodThatReturns`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Int).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `simpleMethodThatReturns`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Int, Int> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Int, Int>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`simpleMethodThatReturns`() -> Int", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Int).self)))
  }

  // MARK: Mocked `simpleMethodThatReturns`(`param`: String)
  public func `simpleMethodThatReturns`(`param`: String) -> String {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`simpleMethodThatReturns`(`param`: String) -> String", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`param`)], returnType: Swift.ObjectIdentifier((String).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (String) -> String { return mkbImpl(`param`) }
      if let mkbImpl = mkbImpl as? () -> String { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: String = mkbObject.`simpleMethodThatReturns`(param: `param`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (String).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `simpleMethodThatReturns`(`param`: @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> String, String> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> String, String>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`simpleMethodThatReturns`(`param`: String) -> String", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`param`)], returnType: Swift.ObjectIdentifier((String).self)))
  }

  // MARK: Mocked `simpleMethodThatReturns`(`optionalParam`: String?)
  public func `simpleMethodThatReturns`(`optionalParam`: String?) -> String? {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`simpleMethodThatReturns`(`optionalParam`: String?) -> String?", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`optionalParam`)], returnType: Swift.ObjectIdentifier((String?).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (String?) -> String? { return mkbImpl(`optionalParam`) }
      if let mkbImpl = mkbImpl as? () -> String? { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: String? = mkbObject.`simpleMethodThatReturns`(optionalParam: `optionalParam`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (String?).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `simpleMethodThatReturns`(`optionalParam`: @autoclosure () -> String?) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String?) -> String?, String?> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String?) -> String?, String?>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`simpleMethodThatReturns`(`optionalParam`: String?) -> String?", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`optionalParam`)], returnType: Swift.ObjectIdentifier((String?).self)))
  }
}

/// Returns a concrete mock of `ProtocolsWithSimpleMethods`.
public func mock(_ type: CleanTranslator.ProtocolsWithSimpleMethods.Protocol, file: StaticString = #file, line: UInt = #line) -> ProtocolsWithSimpleMethodsMock {
  return ProtocolsWithSimpleMethodsMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked TranslationScreenBusinessLogic
public final class TranslationScreenBusinessLogicMock: CleanTranslator.TranslationScreenBusinessLogic, Mockingbird.Mock {
  typealias MockingbirdSupertype = CleanTranslator.TranslationScreenBusinessLogic
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "CleanTranslator"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    TranslationScreenBusinessLogicMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `didLoad`()
  public func `didLoad`() -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`didLoad`() -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`didLoad`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `didLoad`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`didLoad`() -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked `didRequestTranslate`(_ `request`: CleanTranslator.TranslationScreenModels.Update.Request)
  public func `didRequestTranslate`(_ `request`: CleanTranslator.TranslationScreenModels.Update.Request) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`didRequestTranslate`(_ `request`: CleanTranslator.TranslationScreenModels.Update.Request) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`request`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (CleanTranslator.TranslationScreenModels.Update.Request) -> Void { return mkbImpl(`request`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`didRequestTranslate`(`request`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `didRequestTranslate`(_ `request`: @autoclosure () -> CleanTranslator.TranslationScreenModels.Update.Request) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (CleanTranslator.TranslationScreenModels.Update.Request) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (CleanTranslator.TranslationScreenModels.Update.Request) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`didRequestTranslate`(_ `request`: CleanTranslator.TranslationScreenModels.Update.Request) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`request`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns a concrete mock of `TranslationScreenBusinessLogic`.
public func mock(_ type: CleanTranslator.TranslationScreenBusinessLogic.Protocol, file: StaticString = #file, line: UInt = #line) -> TranslationScreenBusinessLogicMock {
  return TranslationScreenBusinessLogicMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked TranslationScreenDisplayLogic
public final class TranslationScreenDisplayLogicMock: CleanTranslator.TranslationScreenDisplayLogic, Mockingbird.Mock {
  typealias MockingbirdSupertype = CleanTranslator.TranslationScreenDisplayLogic
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "CleanTranslator"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    TranslationScreenDisplayLogicMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `displayError`(_ `viewModel`: CleanTranslator.TranslationScreenModels.Error.ViewModel)
  public func `displayError`(_ `viewModel`: CleanTranslator.TranslationScreenModels.Error.ViewModel) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`displayError`(_ `viewModel`: CleanTranslator.TranslationScreenModels.Error.ViewModel) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`viewModel`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (CleanTranslator.TranslationScreenModels.Error.ViewModel) -> Void { return mkbImpl(`viewModel`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`displayError`(`viewModel`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `displayError`(_ `viewModel`: @autoclosure () -> CleanTranslator.TranslationScreenModels.Error.ViewModel) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (CleanTranslator.TranslationScreenModels.Error.ViewModel) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (CleanTranslator.TranslationScreenModels.Error.ViewModel) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`displayError`(_ `viewModel`: CleanTranslator.TranslationScreenModels.Error.ViewModel) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`viewModel`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked `displaySetupScreen`(with `viewModel`: CleanTranslator.TranslationScreenModels.Setup.ViewModel)
  public func `displaySetupScreen`(with `viewModel`: CleanTranslator.TranslationScreenModels.Setup.ViewModel) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`displaySetupScreen`(with `viewModel`: CleanTranslator.TranslationScreenModels.Setup.ViewModel) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`viewModel`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (CleanTranslator.TranslationScreenModels.Setup.ViewModel) -> Void { return mkbImpl(`viewModel`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`displaySetupScreen`(with: `viewModel`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `displaySetupScreen`(with `viewModel`: @autoclosure () -> CleanTranslator.TranslationScreenModels.Setup.ViewModel) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (CleanTranslator.TranslationScreenModels.Setup.ViewModel) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (CleanTranslator.TranslationScreenModels.Setup.ViewModel) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`displaySetupScreen`(with `viewModel`: CleanTranslator.TranslationScreenModels.Setup.ViewModel) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`viewModel`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked `displayTranslatedText`(_ `viewModel`: CleanTranslator.TranslationScreenModels.Update.ViewModel)
  public func `displayTranslatedText`(_ `viewModel`: CleanTranslator.TranslationScreenModels.Update.ViewModel) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`displayTranslatedText`(_ `viewModel`: CleanTranslator.TranslationScreenModels.Update.ViewModel) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`viewModel`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (CleanTranslator.TranslationScreenModels.Update.ViewModel) -> Void { return mkbImpl(`viewModel`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`displayTranslatedText`(`viewModel`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `displayTranslatedText`(_ `viewModel`: @autoclosure () -> CleanTranslator.TranslationScreenModels.Update.ViewModel) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (CleanTranslator.TranslationScreenModels.Update.ViewModel) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (CleanTranslator.TranslationScreenModels.Update.ViewModel) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`displayTranslatedText`(_ `viewModel`: CleanTranslator.TranslationScreenModels.Update.ViewModel) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`viewModel`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns a concrete mock of `TranslationScreenDisplayLogic`.
public func mock(_ type: CleanTranslator.TranslationScreenDisplayLogic.Protocol, file: StaticString = #file, line: UInt = #line) -> TranslationScreenDisplayLogicMock {
  return TranslationScreenDisplayLogicMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked TranslationScreenPresentationLogic
public final class TranslationScreenPresentationLogicMock: CleanTranslator.TranslationScreenPresentationLogic, Mockingbird.Mock {
  typealias MockingbirdSupertype = CleanTranslator.TranslationScreenPresentationLogic
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "CleanTranslator"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    TranslationScreenPresentationLogicMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `presentError`(_ `response`: CleanTranslator.TranslationScreenModels.Error.Response)
  public func `presentError`(_ `response`: CleanTranslator.TranslationScreenModels.Error.Response) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`presentError`(_ `response`: CleanTranslator.TranslationScreenModels.Error.Response) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`response`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (CleanTranslator.TranslationScreenModels.Error.Response) -> Void { return mkbImpl(`response`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`presentError`(`response`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `presentError`(_ `response`: @autoclosure () -> CleanTranslator.TranslationScreenModels.Error.Response) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (CleanTranslator.TranslationScreenModels.Error.Response) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (CleanTranslator.TranslationScreenModels.Error.Response) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`presentError`(_ `response`: CleanTranslator.TranslationScreenModels.Error.Response) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`response`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked `presentSetupScreen`(_ `response`: CleanTranslator.TranslationScreenModels.Setup.Response)
  public func `presentSetupScreen`(_ `response`: CleanTranslator.TranslationScreenModels.Setup.Response) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`presentSetupScreen`(_ `response`: CleanTranslator.TranslationScreenModels.Setup.Response) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`response`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (CleanTranslator.TranslationScreenModels.Setup.Response) -> Void { return mkbImpl(`response`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`presentSetupScreen`(`response`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `presentSetupScreen`(_ `response`: @autoclosure () -> CleanTranslator.TranslationScreenModels.Setup.Response) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (CleanTranslator.TranslationScreenModels.Setup.Response) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (CleanTranslator.TranslationScreenModels.Setup.Response) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`presentSetupScreen`(_ `response`: CleanTranslator.TranslationScreenModels.Setup.Response) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`response`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked `presentTranslation`(_ `response`: CleanTranslator.TranslationScreenModels.Update.Response)
  public func `presentTranslation`(_ `response`: CleanTranslator.TranslationScreenModels.Update.Response) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`presentTranslation`(_ `response`: CleanTranslator.TranslationScreenModels.Update.Response) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`response`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (CleanTranslator.TranslationScreenModels.Update.Response) -> Void { return mkbImpl(`response`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`presentTranslation`(`response`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `presentTranslation`(_ `response`: @autoclosure () -> CleanTranslator.TranslationScreenModels.Update.Response) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (CleanTranslator.TranslationScreenModels.Update.Response) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (CleanTranslator.TranslationScreenModels.Update.Response) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`presentTranslation`(_ `response`: CleanTranslator.TranslationScreenModels.Update.Response) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`response`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns a concrete mock of `TranslationScreenPresentationLogic`.
public func mock(_ type: CleanTranslator.TranslationScreenPresentationLogic.Protocol, file: StaticString = #file, line: UInt = #line) -> TranslationScreenPresentationLogicMock {
  return TranslationScreenPresentationLogicMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked TranslationScreenView
public final class TranslationScreenViewMock: CleanTranslator.TranslationScreenView, Mockingbird.Mock {
  typealias MockingbirdSupertype = CleanTranslator.TranslationScreenView
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "CleanTranslator"])

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> TranslationScreenViewMock {
      let mock: TranslationScreenViewMock = TranslationScreenViewMock()
      mock.mockingbirdContext.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(coder `param1`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> TranslationScreenViewMock? {
      let mock: TranslationScreenViewMock? = TranslationScreenViewMock(coder: `param1`)
      mock?.mockingbirdContext.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked delegate
  override public var `delegate`: CleanTranslator.TranslationScreenViewDelegate? {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "delegate.getter", setterSelectorName: "delegate.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((CleanTranslator.TranslationScreenViewDelegate?).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> CleanTranslator.TranslationScreenViewDelegate? { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as CleanTranslator.TranslationScreenViewDelegate? }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`delegate`
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: CleanTranslator.TranslationScreenViewDelegate? = mkbObject.`delegate`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (CleanTranslator.TranslationScreenViewDelegate?).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
    set {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "delegate.setter", setterSelectorName: "delegate.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? (CleanTranslator.TranslationScreenViewDelegate?) -> Void { return mkbImpl(newValue) }
        if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
        if let mkbImpl = mkbImpl as? (Any?) -> Any { return Mockingbird.dynamicCast(mkbImpl(newValue as Any?)) as Void }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Void }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`delegate` = newValue
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Void = mkbObject.`delegate` = newValue
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getDelegate() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> CleanTranslator.TranslationScreenViewDelegate?, CleanTranslator.TranslationScreenViewDelegate?> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> CleanTranslator.TranslationScreenViewDelegate?, CleanTranslator.TranslationScreenViewDelegate?>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "delegate.getter", setterSelectorName: "delegate.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((CleanTranslator.TranslationScreenViewDelegate?).self)))
  }

  public func setDelegate(_ newValue: @autoclosure () -> CleanTranslator.TranslationScreenViewDelegate?) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (CleanTranslator.TranslationScreenViewDelegate?) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (CleanTranslator.TranslationScreenViewDelegate?) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "delegate.setter", setterSelectorName: "delegate.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.resolve(newValue)], returnType: Swift.ObjectIdentifier(Void.self)))
  }

  // MARK: Mocked init()
  public required override init() {
    super.init()
    self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "init()", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  public func initialize() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "init()", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked `setup`(_ `viewModel`: CleanTranslator.TranslationScreenModels.Setup.ViewModel)
  public override func `setup`(_ `viewModel`: CleanTranslator.TranslationScreenModels.Setup.ViewModel) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`setup`(_ `viewModel`: CleanTranslator.TranslationScreenModels.Setup.ViewModel) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`viewModel`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (CleanTranslator.TranslationScreenModels.Setup.ViewModel) -> Void { return mkbImpl(`viewModel`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`setup`(`viewModel`)
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`setup`(`viewModel`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `setup`(_ `viewModel`: @autoclosure () -> CleanTranslator.TranslationScreenModels.Setup.ViewModel) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (CleanTranslator.TranslationScreenModels.Setup.ViewModel) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (CleanTranslator.TranslationScreenModels.Setup.ViewModel) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`setup`(_ `viewModel`: CleanTranslator.TranslationScreenModels.Setup.ViewModel) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`viewModel`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked `showTranslation`(_ `viewModel`: CleanTranslator.TranslationScreenModels.Update.ViewModel)
  public override func `showTranslation`(_ `viewModel`: CleanTranslator.TranslationScreenModels.Update.ViewModel) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`showTranslation`(_ `viewModel`: CleanTranslator.TranslationScreenModels.Update.ViewModel) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`viewModel`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (CleanTranslator.TranslationScreenModels.Update.ViewModel) -> Void { return mkbImpl(`viewModel`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`showTranslation`(`viewModel`)
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`showTranslation`(`viewModel`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `showTranslation`(_ `viewModel`: @autoclosure () -> CleanTranslator.TranslationScreenModels.Update.ViewModel) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (CleanTranslator.TranslationScreenModels.Update.ViewModel) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (CleanTranslator.TranslationScreenModels.Update.ViewModel) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`showTranslation`(_ `viewModel`: CleanTranslator.TranslationScreenModels.Update.ViewModel) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`viewModel`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked init?(coder `param1`: NSCoder)
  public required init?(coder `param1`: NSCoder) {
    super.init(coder: `param1`)
    self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "init?(coder `param1`: NSCoder)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`param1`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  public func initialize(coder `param1`: @autoclosure () -> NSCoder) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (NSCoder) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (NSCoder) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "init?(coder `param1`: NSCoder)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`param1`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns an abstract mock which should be initialized using `mock(TranslationScreenView.self).initialize(…)`.
public func mock(_ type: CleanTranslator.TranslationScreenView.Type, file: StaticString = #file, line: UInt = #line) -> TranslationScreenViewMock.InitializerProxy.Type {
  return TranslationScreenViewMock.InitializerProxy.self
}

// MARK: - Mocked TranslationScreenWorkerProtocol
public final class TranslationScreenWorkerProtocolMock: CleanTranslator.TranslationScreenWorkerProtocol, Mockingbird.Mock {
  typealias MockingbirdSupertype = CleanTranslator.TranslationScreenWorkerProtocol
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "CleanTranslator"])

  // MARK: Mocked translationModelId
  public var `translationModelId`: String {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "translationModelId.getter", setterSelectorName: "translationModelId.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((String).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> String { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as String }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            break
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: String = mkbObject.`translationModelId`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (String).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getTranslationModelId() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String, String> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String, String>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "translationModelId.getter", setterSelectorName: "translationModelId.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((String).self)))
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    TranslationScreenWorkerProtocolMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `translate`(`text`: String, `completion`: @escaping (Result<[CleanTranslator.TranslationModel], Error>) -> Void)
  public func `translate`(`text`: String, `completion`: @escaping (Result<[CleanTranslator.TranslationModel], Error>) -> Void) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`translate`(`text`: String, `completion`: @escaping (Result<[CleanTranslator.TranslationModel], Error>) -> Void) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`text`), Mockingbird.ArgumentMatcher(`completion`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (String, @escaping (Result<[CleanTranslator.TranslationModel], Error>) -> Void) -> Void { return mkbImpl(`text`, `completion`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`translate`(text: `text`, completion: `completion`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `translate`(`text`: @autoclosure () -> String, `completion`: @autoclosure () -> (Result<[CleanTranslator.TranslationModel], Error>) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String, @escaping (Result<[CleanTranslator.TranslationModel], Error>) -> Void) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String, @escaping (Result<[CleanTranslator.TranslationModel], Error>) -> Void) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`translate`(`text`: String, `completion`: @escaping (Result<[CleanTranslator.TranslationModel], Error>) -> Void) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`text`), Mockingbird.resolve(`completion`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns a concrete mock of `TranslationScreenWorkerProtocol`.
public func mock(_ type: CleanTranslator.TranslationScreenWorkerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> TranslationScreenWorkerProtocolMock {
  return TranslationScreenWorkerProtocolMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}
